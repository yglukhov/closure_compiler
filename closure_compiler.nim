import httpclient, cgi, pegs, sets, os, osproc, strutils, streams, json

type CompilationLevel* = enum
    SIMPLE_OPTIMIZATIONS
    WHITESPACE_ONLY
    ADVANCED_OPTIMIZATIONS

proc urlencode(params: openarray[tuple[k : string, v: string]]): string =
    result = ""
    for i, p in params:
        if i != 0:
            result &= "&"
        result &= encodeUrl(p.k)
        result &= "="
        result &= encodeUrl(p.v)

proc nimblePath(package: string): string =
    var nimblecmd = "nimble"
    var (nimbleNimxDir, err) = execCmdEx(nimblecmd & " path " & package)
    if err == 0:
        let lines = nimbleNimxDir.splitLines()
        if lines.len > 1:
            result = lines[^2]

proc closureCompilerExe(): string =
    if findExe("java").len == 0: return
    let ccpath = nimblePath("closure_compiler")
    if ccpath.len != 0:
        result = ccpath / "compiler-latest" / "compiler.jar"

# Javascript generated by Nim has some incompatibilities with closure compiler
# advanced optimizations:
# - Some properties are accessed by indexing (in nimCopy) and by dot-syntax. E.g:
#       myObj["Field1"]
#       myObj.Field1
# - Another case is passing properties by "ptr". E.g:
#       del(myObj, "myMemberSequence", 5)
#   Closure compiler does not expect non-uniform property access, so we need
#   to extern such properties, so that it doesn't rename them.
#   In order to collect such properties, we look for anything like a valid
#   identifier in a JS string literal.
proc externsFromNimSourceCode(code: string): string =
    result = ""
    let p = peg""" \" {\ident} \" """
    var matches = code.findAll(p)
    for m in matches.mitems:
        var s : array[1, string]
        discard m.match(p, s)
        m = s[0]

    for i in matches.toHashSet():
        result &= "Object.prototype." & i & ";\n"

proc runProcess(command: string, args: openarray[string]) =
    var process = startProcess(command = command, args = args, options = {poParentStreams, poStdErrToStdOut})
    var exitCode = process.waitForExit()
    if exitCode != 0:
        raiseOSError(OSErrorCode(exitCode), "closure_compiler exit with code: " & $exitCode)

proc runLocalCompiler(compExe, sourceCode: string, level: CompilationLevel): string =
    let externs = externsFromNimSourceCode(sourceCode)
    let inputPath = getTempDir() / "closure_input.js"
    let externPath = getTempDir() / "closure_js_extern_tmp.js"
    let outputPath = getTempDir() / "closure_output.js"
    writeFile(externPath, externs)
    writeFile(inputPath, sourceCode)

    runProcess(findExe("java"), ["-jar", compExe, inputPath, "--compilation_level", $level,
        "--externs", externPath, "--js_output_file", outputPath, "--jscomp_off=uselessCode", "--jscomp_off=es5Strict", "--strict_mode_input=false", "--warning_level=QUIET"])
    removeFile(inputPath)
    result = readFile(outputPath)
    removeFile(outputPath)
    removeFile(externPath)

proc runLocalCompiler(compExe, inputPath: string, level: CompilationLevel, srcMap: bool) =
    let externs = externsFromNimSourceCode(readFile(inputPath))
    let workDir = parentDir(inputPath)

    let backupPath = workDir / "before_closure.js"
    let outputPath = inputPath

    let externPath = workDir / "closure_js_extern_tmp.js"
    writeFile(externPath, externs)

    removeFile(backupPath)
    moveFile(inputPath, backupPath)

    var args = @["-jar", compExe, backupPath, "--compilation_level", $level,
        "--externs", externPath, "--js_output_file", outputPath, "--jscomp_off=uselessCode", "--jscomp_off=es5Strict", "--strict_mode_input=false", "--warning_level=QUIET"]

    if srcMap:
        let sourceMapPath = workDir / "closure-src-map"
        args.add(["--create_source_map", sourceMapPath,
            "--source_map_location_mapping", backupPath & "|" & extractFilename(backupPath)])

    runProcess(findExe("java"), args)

    if srcMap:
        let f = open(outputPath, fmAppend)
        f.write("\L//# sourceMappingURL=closure-src-map\L")
        f.close()
    else:
        removeFile(backupPath)
    removeFile(externPath)

proc runWebAPICompiler(sourceCode: string, level: CompilationLevel): string =
    let externs = externsFromNimSourceCode(sourceCode)
    var data = urlencode({
        "compilation_level" : $level,
        "output_format" : "json",
        "output_info" : "compiled_code",
        "js_code" : sourceCode,
        "js_externs" : externs
        })
    let cl = newHttpClient()
    cl.headers["Content-type"] = "application/x-www-form-urlencoded"
    let resp = cl.postContent("http://closure-compiler.appspot.com/compile", body = data)
    cl.close()
    var j: JsonNode
    try:
        j = parseJson(resp)
    except:
        echo "Could not parse closure compiler web api response: ", resp
        raise

    result = j{"compiledCode"}.getStr()
    if result.len == 0:
        echo "Could not compile with closure compiler web api: ", j
        raise newException(Exception, "Could not compile with closure compiler web api")

proc compileSource*(sourceCode: string, level: CompilationLevel = SIMPLE_OPTIMIZATIONS): string =
    let compExe = closureCompilerExe()
    if compExe.len > 0:
        result = runLocalCompiler(compExe, sourceCode, level)
    else:
        result = runWebAPICompiler(sourceCode, level)

proc compileFile*(f: string, level: CompilationLevel = SIMPLE_OPTIMIZATIONS): string = compileSource(readFile(f), level)

proc compileFileAndRewrite*(f: string, level: CompilationLevel = SIMPLE_OPTIMIZATIONS, produceSourceMap: bool = false): bool {.discardable.} =
    result = true
    let compExe = closureCompilerExe()
    if compExe.len > 0:
        runLocalCompiler(compExe, f, level, produceSourceMap)
    else:
        writeFile(f, runWebAPICompiler(readFile(f), level))

when isMainModule:
    import parseopt

    proc usage() =
        echo "closure_compiler [-q] [-a|-w] file1 [fileN...]"

    proc printVersion() =
        let compExe = closureCompilerExe()
        runProcess(findExe("java"), ["-jar", compExe, "--version"])

    proc main() =
        var files = newSeq[string]()
        var level = SIMPLE_OPTIMIZATIONS
        var quiet = false
        for kind, key, val in getopt():
            case kind
            of cmdArgument: files.add(key)
            of cmdShortOption:
                case key
                of "a": level = ADVANCED_OPTIMIZATIONS
                of "w": level = WHITESPACE_ONLY
                of "q": quiet = true
                else:
                    usage()
                    return
            of cmdLongOption:
                case key
                of "version":
                    printVersion()
                    return
                else:
                    usage()
                    return
            else:
                usage()
                return

        if files.len == 0:
            usage()
            return

        for f in files:
            if not quiet:
                echo "Processing: ", f
            compileFileAndRewrite(f, level)

    main()
